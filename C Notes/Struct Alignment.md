# Struct Alignment

# **結構體對齊的定義、解釋與判斷**

## **定義**

### **結構體對齊（Structure Alignment）**

- 編譯器為了提高記憶體存取效率，會按照特定的對齊規則安排結構體成員的位址。
- 這些規則決定了成員在結構體中的偏移量，以及整個結構體的大小。

### 白話

- CPU 存取資料時，通常在對齊的位址上效率更高。
- 編譯器會在結構體成員之間插入額外的填充位元組（Padding），使每個成員都對齊到其對齊要求的位址上。

---

## **如何判斷對齊**

1. **成員對齊規則：**
    - 每個成員的偏移量（Offset）必須是該成員大小或對齊值的倍數。
2. **結構體總大小對齊：**
    - 結構體的總大小必須是其最大對齊值的倍數。

**64-bit 和 32-bit 電腦的差異：**

- **對齊要求可能不同：**
    - 在 64-bit 系統中，某些型別（如指標、`long`）的大小和對齊值會增加。
- **以誰為準：**
    - 通常以結構體中對齊要求最大的成員為準，決定結構體的總對齊值。

## 範例

### **範例 1**

```cpp
struct Example1 {
    char a;    // 1 位元組
    int b;     // 4 位元組
    short c;   // 2 位元組
};

```

**分析：**

- size最大的是int，4位元。
- `char a` 偏移量是0，佔1位元。
- `int b` 需要 4 位元，且`a` 後偏移量必須是 4 的倍數。
    - 因此，`a` 後需要 3 位元組的填充，使 `b` 的偏移量為 4，佔4位元。
- `short c` 需要 2 位元，且`b` 後的偏移量為 8。
    - `c` 的偏移量為 8，不需要填充，佔2位元。
- 結構體的總大小需要是最大對齊值（4）的倍數。
    - 目前大小為 10 位元組，需要填充 2 位元組，使總大小為 12 位元組。

**優化順序：**

```cpp
struct Example1_Optimized {
    int b;     // 4 位元組
    short c;   // 2 位元組
    char a;    // 1 位元組
    // 填充 1 位元組，使總大小為 8 位元組
};

```

### **範例2**

```cpp
struct Example2 {
    double d;   // 8 位元組
    char c;     // 1 位元組
    int i;      // 4 位元組
};

```

**分析：**

- size最大的是double，8位元。
- `double d` 的偏移量為 0，佔8位元。
- `char c` 的偏移量為 8，佔1位元。
- `int i` 需要 4 位元，且`c`後偏移量必須是 4 的倍數。
    - `c` 後的偏移量為 9，不是 4 的倍數，需要填充 3 位元組，使 `i` 的偏移量為 12。
- 結構體的總大小需要是最大對齊值（8）的倍數。
    - 目前大小為 16 位元組，已經是 8 的倍數。

## **如何調整順序，減少記憶體佔用：**

- **原則：**
    - 將對齊要求大的成員放在前面，對齊要求小的成員放在後面。
- **目的：**
    - 減少填充位元組的數量，降低結構體的總大小。