# Static & const & extern

# Static

## `static` 的三種使用情境

### **函數內的靜態變量**

- **定義**：在函數內部使用 `static` 關鍵字定義的變量，其作用域僅限於該函數，但生命周期為整個程序執行期間。
- **行為**：只在第一次調用時初始化，後續調用保持其值。
- **範例**：
    
    ```cpp
    void countCalls() {
        static int count = 0;
        count++;
        std::cout << "Function called " << count << " times." << std::endl;
    }
    int main()
    {
        countCalls();
        countCalls();
    	return 0;
    }
    
    output:
    Function called 1 times.
    Function called 2 times.
    ```
    

### **文件內的靜態全局變量或函數**

- **定義**：在文件作用域使用 `static` 定義的變量或函數，其作用域僅限於該源文件，不能被其他文件訪問。（有點類似extern的相反）
- **用途**：防止命名衝突，實現封裝。
- **範例**：
    
    ```cpp
    static int fileScopedVar = 0; // 謹在此文件內可用
    
    static void helperFunction() {
        // 僅在此文件內可用
    }
    ```
    

### **類的靜態成員**

- **定義**：使用 `static` 關鍵字定義的類成員（變數和函式）屬於類本身，而不是某個對象實例。
- **行為**：所有對象共享同一個靜態成員。
- **範例**：
    
    ```cpp
    class MyClass {
    public:
        static int sharedValue;
        static void staticMethod() {
            // 訪問或修改 sharedValue
            // 只有static函式可以修改static變數
        }
    };
    
    int MyClass::sharedValue = 0;
    MyClass::staticMethod(); // 不用宣告類別實例，也可以取用該函式。
    ```
    

## 底層處理

### 成因

- **函數內的靜態變量**：存儲在靜態存儲區，編譯時確定內存大小，執行前分配內存，執行時初始化一次。
- **文件內的靜態變量或函數**：作用域限制在編譯單元內，避免外部鏈接。
- **類的靜態成員**：在全局作用域下存在，需要在類外進行定義。

### **編譯順序**

- **預處理：**`Macro`替換、包含頭文件等（以`#`開頭的指令）。
- 編譯：將源程式碼轉換為目標程式碼（source code to object code）。
    - source code & object code
        
        **源程式碼（Source Code）**：
        
        - 指的是程序員使用高級編程語言（如C、C++、Java、Python等）編寫的原始程式碼。
        - 它是人類可讀的，包含了程序的邏輯、結構和功能實現。
        - 例如，一個用C語言寫的簡單程序：
        
        ```c
        #include <stdio.h>
        
        int main() {
            printf("Hello, World!\\n");
            return 0;
        }
        ```
        
        **目標程式碼（Object Code）**：
        
        - 是源程式碼經過編譯器處理後生成的機器碼，通常是二進制格式。
        - 它是計算機可以直接執行的指令，但通常還需要進一步的鏈接（linking）步驟來生成可執行文件。
        - 目標程式碼包含了機器指令、數據、符號表等信息，但不可直接被人類閱讀。
        
        **兩者之間的關係**：
        
        - **編譯過程**：源程式碼通過編譯器轉換為目標程式碼。這個過程包括語法分析、語義分析、優化和程式碼生成等步驟。
        - **鏈接過程**：多個目標程式碼文件和庫文件通過鏈接器（linker）整合，生成最終的可執行文件。
        - **可移植性**：源程式碼是跨平台的，只要有相應的編譯器，源程式碼可以在不同的系統上編譯成適用於該系統的目標程式碼。目標程式碼通常是針對特定硬件和操作系統的。
        
        總結來說，源程式碼是程序員撰寫的高級指令，而目標程式碼是計算機能夠理解和執行的低級指令。編譯器在兩者之間起到了橋樑的作用，將人類可讀的源程式碼轉換為機器可執行的目標程式碼。
        
- 連接：將各個目標程式碼和庫文件進行合併，解決符號引用。

---

# Const

## `const` 的使用

### **定義**

- `const` 關鍵字用於定義不可修改的變量（Read-Only），提高程序的安全性和可讀性。

### **使用情境**

- 定義常量。
    
    ```cpp
    const int MAX_SIZE = 100;
    ```
    
- 修飾函數參數，防止意外修改。
- 修飾成員函數，表示該函數不修改對象的狀態。

### const的幾種使用方法

```cpp
const int x = 10;           // 定義一個不可修改的整數常量
const int *ptr = &x;        // 指向常量的指標，指標可以改，常量整數不可改
int * const ptr2 = &y;      // 常量指針，不可修改指針的指向，但可修改指向的整數值
const int * const ptr3 = &z; // 同時為指向常量的指標和常量指標，指標和整數皆不可改
```

## **底層實作**

### 預處理階段

預處理器處理以 `#` 開頭的指令，如 `#include` 和 `#define`。`const` 關鍵字本身在此階段不會被特別處理，但如果 `const` 被用在宏中，則會在此階段展開。

**範例：**

```c
#define MAX_SIZE 100
const int size = MAX_SIZE;
```

預處理後變為：

```c
const int size = 100;
```

### 編譯階段

編譯器將預處理後的程式碼轉換為中間表示（如抽象語法樹 AST），並進行語法分析和語義分析。在此階段，`const` 的處理包括：

- **符號表處理**：記錄變量的屬性，包括 `const` 修飾，供後續檢查和程式碼生成使用。
- **類型檢查**：確保 `const` 修飾的變量不被修改，若有嘗試修改，編譯器會報錯。
- **優化**：利用 `const` 的不變性進行優化，如常量折疊和內聯。
- **程式碼生成**：將 `const` 變量存儲在只讀內存區（如 `.rodata` 段），防止在運行時被修改。

**範例：**

```c
const int x = 10;
x = 20; // 編譯錯誤

```

### 組譯與連結階段

- **組譯階段**：將編譯器生成的中間程式碼轉換為機器碼，生成目標文件（如 `.o` 或 `.obj`），其中包含 `const` 變量的信息（通常在 `.rodata` 段）。
- **連結階段**：連結器將多個目標文件和庫文件合併成最終的可執行文件，解析 `const` 變量的地址和屬性，確保它們在只讀內存區中正確定位。

## `const` 的底層實作與優化

### 存儲位置與內存保護

`const` 變量通常存儲在只讀數據段（`.rodata`）中。操作系統在加載可執行文件時，將這些段設置為只讀，防止在運行時被修改。

**範例：**

```c
const int x = 10;

```

在編譯後，`x` 會被放置在 `.rodata` 段，而非可寫的 `.data` 段。

### 編譯器優化

編譯器利用 `const` 的不可變性進行多種優化，以提升執行效率和減少資源消耗：

- **常量折疊（Constant Folding）**：在編譯時計算表達式的值，減少運行時計算。
    
    ```c
    const int a = 5;
    const int b = a + 10; // 編譯器可優化為 b = 15
    
    ```
    
- **內聯（Inlining）**：將 `const` 變量的值直接替換到使用它的地方，減少內存訪問。
- **只讀內存分配**：將 `const` 變量分配到只讀內存區，提升內存訪問效率並保護數據。

### 防止非法修改

除了在內存層面設置只讀屬性，編譯器在語言層面也強制 `const` 的不可變性：

- **語法限制**：禁止直接修改 `const` 變量，若嘗試修改會在編譯階段報錯。
    
    ```c
    const int x = 10;
    x = 20; // 編譯錯誤
    
    ```
    
- **指針限制**：通過指針或引用修改 `const` 變量會導致未定義行為，編譯器通常會發出警告或錯誤。
    
    ```c
    const int x = 10;
    int *p = (int *)&x;
    *p = 20; // 未定義行為，可能導致運行時錯誤
    
    ```
    
- **C++ 的 `const_cast`**：雖然可以在 C++ 中使用 `const_cast` 強制轉換，繞過 `const` 限制，但這會導致未定義行為，應謹慎使用。

### 多線程與連結考量

- **多線程環境**：`const` 有助於確保數據不被修改，減少同步需求，但仍需注意對象的不可變性。
- **跨編譯單位使用 `const`**：全局 `const` 變量默認具有內部連結（`static`），若需跨編譯單位使用，需明確指定 `extern`。
    
    ```c
    // file1.c
    extern const int x = 10; // 明確指定外部連結
    
    // file2.c
    extern const int x; // 正確引用
    
    ```
    

## 總結

`const` 關鍵字在 C/C++ 中不僅提供了定義不可變變量的能力，還通過編譯器和操作系統的協同工作，確保這些變量在程序運行時的安全性和效率。從預處理、編譯到連結的每個階段，`const` 的屬性都被嚴格處理和優化，使得開發者能夠編寫更可靠和高效的程式碼。

---

# extern

`extern` 是 C 和 C++ 語言中用來處理變量和函數鏈接（Linkage）的關鍵字。

## `extern` 的使用方式

### 變量的聲明與定義

- **定義（Definition）**：在一個源文件中實際分配內存。
    
    ```c
    // file1.c
    int sharedVar = 42; // 定義變量
    
    ```
    
- **聲明（Declaration）**：在其他源文件中聲明該變量，告知編譯器變量在其他地方定義，避免重複定義。
    
    ```c
    // file2.c
    extern int sharedVar; // 聲明變量
    
    ```
    

### 函數的 `extern` 使用

- **默認外部鏈接**：C 語言中，函數默認具有 `extern` 屬性，不需顯式使用 `extern`。
    
    ```c
    // header.h
    void sharedFunction(); // 默認為 extern
    
    ```
    
- **顯式 `extern`**：在頭文件中顯式使用 `extern` 提高可讀性。
    
    ```c
    // header.h
    extern void sharedFunction();
    
    ```
    

### C++ 中的 `extern "C"`

- **防止名稱修飾**：在 C++ 中使用 `extern "C"` 以 C 語言風格鏈接函數，實現 C 和 C++ 間的互操作性。
    
    ```cpp
    // header.h
    #ifdef __cplusplus
    extern "C" {
    #endif
    
    void cFunction();
    
    #ifdef __cplusplus
    }
    #endif
    
    ```
    

## 編譯階段中的處理

### 預處理階段

- **`Macro`展開與包含文件**：預處理器處理 `#include` 指令，將 `extern` 聲明展開到源文件中。
    
    ```c
    // header.h
    extern int sharedVar;
    
    // file1.c
    #include "header.h"
    int sharedVar = 42;
    
    // file2.c
    #include "header.h"
    ```
    
    預處理後，`file2.c` 中的 `extern int sharedVar;` 將被展開，告訴編譯器該變量在其他地方(`file1.c`)定義。
    

### 編譯階段

- **符號表處理**：編譯器在符號表中記錄 `extern` 聲明的變量和函數，標記其為外部鏈接。
- **類型檢查**：確保所有對 `extern` 變量或函數的使用與其定義相匹配，類型一致，避免類型錯誤。

### 組譯階段

- **目標文件生成**：編譯器將源碼轉成組合語言後，再轉換為機器碼，生成目標文件（如 `.o` 或 `.obj`），其中 `extern` 聲明的符號被標記為未解析（Undefined Symbols）。

## 連結階段的實作與底層處理

### 符號解析與鏈接

- **符號表合併**：連結器將所有目標文件的符號表合併，查找並匹配 `extern` 聲明的符號與其定義。
- **重定位**：連結器將 `extern` 符號的引用替換為具體的內存地址，確保所有引用指向正確的定義。

### 內存分配與段佈局

- **數據段與文本段**：
    - **全局變量**：分配在數據段（`.data`）或只讀數據段（`.rodata`）中，具體取決於是否為 `const`。
    - **函數**：分配在文本段（`.text`）中，包含可執行程式碼。
- **內存保護**：操作系統在加載可執行文件時，設置不同段的訪問權限，例如文本段為只執行，不可寫。

### 3. 多重聲明與唯一定義

- **唯一定義原則（One Definition Rule, ODR）**：每個全局變量和函數應在整個程序中只有一個定義。多個聲明（使用 `extern`）是允許的，但多個定義會導致連結錯誤。
    
    ```c
    // file1.c
    int sharedVar = 42;
    
    // file2.c
    int sharedVar = 100; // 錯誤：重複定義
    
    ```
    

### 4. 靜態與外部鏈接的區別

- **外部鏈接（External Linkage）**：使用 `extern` 的符號可在多個翻譯單位中引用和定義。
- **內部鏈接（Internal Linkage）**：使用 `static` 關鍵字的符號僅在定義所在的翻譯單位內可見，無法被其他翻譯單位引用。
    
    ```c
    // file1.c
    static int internalVar = 10; // 內部鏈接
    int externalVar = 20;        // 外部鏈接
    
    // file2.c
    extern int externalVar; // 合法
    extern int internalVar; // 錯誤：無法引用內部鏈接的變量
    
    ```
    

## 總結

`extern` 關鍵字在 C 和 C++ 中用於聲明外部變量和函數，實現跨文件的符號共享。其主要功能包括：

1. **聲明與定義的區分**：在一個文件中定義變量，其他文件中聲明以避免重複定義。
2. **編譯階段的符號處理**：編譯器標記 `extern` 符號為未解析，等待連結器來解析其定義。
3. **連結階段的符號解析**：連結器將 `extern` 符號與其定義匹配，完成內存地址的分配與重定位，確保程序的正確運行。

正確使用 `extern` 能夠有效管理多文件項目中的全局資源，避免鏈接錯誤，提升程式碼的可維護性和模塊化程度。