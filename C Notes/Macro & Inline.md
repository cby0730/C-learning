# Macro & Inline

# Macro

## Marco的定義與作用

**Macro** 是一種預處理指令，用於在編譯前對代碼進行文本替換。

### **定義方式**

```cpp
#define PI 3.14159
#define MAX(a, b) ((a) > (b) ? (a) : (b))

```

### **作用**

- **常量定義**：避免使用魔術數（Magic Numbers），提高代碼可讀性。
- **代碼片段替換**：實現簡單的函數或條件編譯。

## Marco的使用情境與底層處理

### **使用情境**

- 定義常量或代碼片段，減少重複代碼。
- 實現條件編譯，控制代碼的編譯過程。

### **底層處理**

- 在預處理階段，編譯器會對代碼中的Macro進行文本替換。
- Macro沒有類型檢查，可能導致意外的錯誤。

## Marco問題

### 範例

```cpp
#include <iostream>

#define MAX(a, b) ((a > b) ? (a) : (b))

int main() {
    int a = 5;
    int b = 5;
    int result = MAX(a++, ++b); // (a++ > ++b) ? (a++) : (++b)
    std::cout << "a: " << a << ", b: " << b << ", MAX(a++, ++b): " << result << std::endl;
    return 0;
}

output:
a: 6, b: 7, MAX(a++, ++b): 7
```

### 原因

- `Macro`就是很純粹的代換文字，不考慮型別，不考慮語意，所以不注意會產生很多的問題。
- 如果`a`和`b`型別不同，也會產生問題。

## 三元運算子

### 範例

```cpp
a ? b : c
// a 成立 -> b
// a 不成立 -> c
```

### 特性

- 可以讓編譯器產生比 if-else 更優化的程式碼。

---

# Inline

## `inline` 的重點

### **定義**：

- `inline` 是C++中的關鍵字，用於建議編譯器將函式的呼叫點替換為函式本體，以減少函式呼叫的開銷。

### **作用**：

- **減少函式呼叫開銷**：避免堆疊操作，提高執行效率。
- **增強優化機會**：編譯器可對展開後的代碼進行更深層的優化。

### **使用情境**

- **短小且頻繁呼叫的函式**：如簡單的存取器（getter）或設定器（setter）。
- **在多個翻譯單元中定義的函式**：避免多重定義錯誤。
- **避免大型函式**：過度內聯可能導致程式碼膨脹，降低效能。

### **優於宏的原因**

- **類型安全**：遵循C++的類型系統，避免類型錯誤。
- **單次評估參數**：避免宏多次評估參數導致的副作用。
- **更好的調試支持**：內聯函式在調試時更易理解和管理。
- **範圍與命名空間**：遵循C++的範圍規則，避免命名衝突。
- **支持函式特性**：如重載、預設參數、模板等。

## `inline` 的處理階段詳解

### 預處理階段

- **不處理 `inline`**：`inline` 關鍵字不在預處理階段被處理。預處理階段主要處理宏展開（`#define`）、檔案包含（`#include`）等指令，而 `inline` 是C++語法的一部分，屬於編譯階段處理。

### 編譯階段

- **標記函式為內聯**：
    - 編譯器在語法分析時識別 `inline` 關鍵字，將其標記為建議內聯的函式。
- **內聯展開（Inline Expansion）**：
    - **替換函式呼叫**：在編譯過程中，編譯器會將函式呼叫點替換為函式本體的代碼，消除函式呼叫的開銷。
    - **條件判斷**：`inline` 僅為編譯器提供內聯建議，最終是否內聯由編譯器根據函式的複雜度、大小及優化策略決定。
- **多重定義處理**：
    - 內聯函式可以在多個翻譯單元中定義，編譯器會在鏈接階段將這些定義合併，避免多重定義錯誤。這是因為內聯函式具有 **弱符號**（weak symbol）的特性。

### 優化機會

- **常量折疊（Constant Folding）**：如果函式參數是常量，編譯器可以在編譯時計算結果。
- **死碼消除（Dead Code Elimination）**：未使用的內聯代碼可以被移除。
- **循環展開（Loop Unrolling）**：在迴圈中使用內聯函式時，編譯器可能會進行循環展開，提高效能。

## `inline` 函式

### 範例

```cpp
#include <iostream>

inline int max_func(int a, int b) {
    return (a > b) ? a : b;
}
// Expand: 
// int temp1 = a++;
// int temp2 = ++b;
// int result = (temp1 > temp2) ? temp1 : temp2;

int main() {
    int x = 5, y = 10;
    int max_val = max_func(x++, y++);
    std::cout << "x: " << x << ", y: " << y << ", max_func(x++, y++): " << max_val << std::endl;
    return 0;
}

output:
x: 6, y: 11, max_func(x++, y++): 10
```

### 特性

- 每個參數只被評估一次，避免了宏的多次評估問題。

## 總結

### **處理階段**

- `inline` 不在預處理階段被處理，而是在編譯階段，編譯器根據內聯建議進行函式展開。

### **優點**

- 提供類型安全、避免多次參數評估、支持C++函式特性，並且在多翻譯單元中安全使用。

### **建議**

- 優先使用 `inline` 函式來替代簡單的宏，提升程式碼的可讀性、安全性和可維護性。