# 內存分佈

# **內存區塊詳細介紹**

## **程式碼段（Code Segment/Text Segment）**

- **內容：**
    - 存放可執行的機器指令，即程式的實際執行代碼。
- **特點：**
    - **只讀性：** 通常設置為只讀，防止在執行期間被修改，增強程式的安全性和穩定性。
    - **共享性：** 多個進程可以共享相同的程式碼段，節省內存資源。

## **只讀數據段（Read-Only Data Segment/.rodata）**

- **內容：**
    - 存放常量、字串字面值和其他不可修改的變數。例如，`const` 修飾的變數和字符串字面量。
- **特點：**
    - **只讀性：** 設置為只讀，防止意外或惡意修改。
    - **內存保護：** 與程式碼段相似，利用內存保護機制增強安全性。
    - **位置：** 緊接在程式碼段（`.text`）之後，位於初始化數據段（`.data`）之前。

## **數據段（Data Segment）**

數據段分為初始化數據段和未初始化數據段，用於存放全域和靜態變數。

### **初始化數據段（.data）**

- **內容：**
    - 存放已初始化的全域和靜態變數。例如，`int global_var = 10;`。
- **特點：**
    - **可讀寫性：** 變數的初始值由程式在編譯時設定，並在運行時可被讀取和修改。
    - **持久性：** 變數在整個程式運行期間保持存在。

### **未初始化數據段（.bss）**

- **內容：**
    - 存放未初始化的全域和靜態變數。例如，`static int uninit_var;`。
- **特點：**
    - **默認初始化：** 系統默認將這些變數初始化為 0。
    - **節省空間：** 不在可執行文件中存儲實際數據，節省磁碟空間，內存中在載入時才分配。

## **堆區（Heap）**

- **內容：**
    - 動態分配的內存，例如通過 `new`（C++）或 `malloc`（C）分配的內存。
- **特點：**
    - **動態管理：** 需要開發者手動分配和釋放，或由垃圾回收機制管理。
    - **內存位址增長方向：** 內存位址從低向高增長。
    - **靈活性：** 適合需要在運行時動態調整大小的資料結構，如鏈表、樹等。

## **堆疊（Stack）**

- **內容：**
    - 存放函數的參數、返回地址、局部變數等。
- **特點：**
    - **自動管理：** 由編譯器自動管理，無需手動分配和釋放。
    - **內存位址減少方向：** 內存位址從高向低減少。
    - **快速訪問：** 由於其後進先出（LIFO）的結構，分配和釋放速度極快。

## **命令列參數和環境變數**

- **內容：**
    - 存放程序的命令列參數和環境變數，用於在程式啟動時傳遞配置和設定。

---

## **內存分佈圖**

以下圖示展示了一般程式在執行時的內存分佈情況：

```cpp
高位址
+------------------------+
|          Stack         |
+------------------------+
|          Heap          |
+------------------------+
|          Uninit        |
+------------------------+
|          Init          |
+------------------------+
|     Read only data     |
+------------------------+
|          Text          |
+------------------------+
低位址

```

### **說明：**

- **高位址端：** Stack位於內存的高位址，隨著函數調用的進行而向下擴展。
- **低位址端：** 程式碼段位於內存的低位址，隨著程式的載入順序而排列。

---

## **heap和stack的速度差異及成因**

### **速度差異**

| 內存區塊 | 分配和釋放速度 | 訪問速度 | 成本 |
| --- | --- | --- | --- |
| **Stack** | **快，**分配和釋放僅需調整堆疊指標，時間複雜度為 O(1)。 | **快，**內存連續，快取命中率高。 | **低，**由編譯器自動管理，無需額外開銷。 |
| Heap | **慢，**需要透過動態分配器管理，涉及內存搜尋和碎片整理。 | **相對慢，**不同區塊內存可能不連續，快取命中率較低。 | **高，**需要手動管理或由垃圾回收機制處理，增加開銷。 |

### **成因分析**

### **內存管理機制**

- **堆疊（Stack）：**
    - **後進先出（LIFO）結構：** 內存的分配和釋放按順序進行，僅需調整堆疊指標。
    - **自動管理：** 由編譯器在編譯時確定，無需運行時干預。
- **堆區（Heap）：**
    - **自由列表管理：** 使用資料結構（如自由列表、位圖等）來追蹤可用內存塊。
    - **碎片整理：** 分配和釋放內存時可能導致內存碎片，需要進行整理以提高效率。
    - **複雜算法：** 動態分配器需要使用更複雜的算法來找到合適的內存塊，增加了時間複雜度。

### **內存佈局和快取性能**

- **Stack：**
    - **內存連續：** 變數按順序存放，具備良好的空間和時間局部性。
    - **高快取命中率：** CPU 更容易預測和快取，提升訪問速度。
- **Heap：**
    - **內存不連續：** 由於動態分配，內存塊可能散佈在不同位置。
    - **低快取命中率：** 訪問時可能需要更多的快取行填充，增加延遲。

### **系統呼叫開銷**

- **堆疊（Stack）：**
    - **無需系統呼叫：** 所有操作在用戶態完成，無需進入內核態，減少開銷。
- **堆區（Heap）：**
    - **可能涉及系統呼叫：** 大量內存分配可能需要系統呼叫（如 `sbrk`、`mmap`）進入內核態，增加時間和資源開銷。

---

## **其他補充**

### **內存對齊（Memory Alignment）**

- **概念：**
    - 為了提高內存訪問效率，數據在內存中按其大小的倍數進行對齊。例如，32位整數通常按4字節對齊。
- **影響：**
    - **性能提升：** 正確對齊可減少 CPU 訪問內存的次數，提升數據讀寫速度。
    - **硬件要求：** 某些架構對內存對齊有嚴格要求，不對齊可能導致訪問錯誤或性能下降。

### **靜態和動態內存分配的區別**

- **靜態分配：**
    - **時間：** 在編譯時確定內存大小和位置。
    - **存放區域：** 全域變數、靜態變數存放在數據段（初始化數據段 `.data` 或未初始化數據段 `.bss`）。
    - **優點：** 分配和釋放速度快，自動管理。
    - **缺點：** 靈活性差，無法在運行時調整大小。
- **動態分配：**
    - **時間：** 在運行時根據需求分配內存。
    - **存放區域：** 堆區（Heap）。
    - **優點：** 高靈活性，能夠根據需求動態調整大小。
    - **缺點：** 分配和釋放速度較慢，易導致內存碎片和洩漏。

### **變數的存儲示例**

- **程式碼段：**
    - **範例：**
        
        ```c
        void function() {
            // 機器指令存放於程式碼段
        }
        
        ```
        
- **只讀數據段：**
    - **範例：**
        
        ```c
        const char *msg = "Hello, World!";
        
        ```
        
- **初始化數據段：**
    - **範例：**
        
        ```c
        int global_var = 10;
        
        ```
        
- **未初始化數據段：**
    - **範例：**
        
        ```c
        static int uninit_var;
        
        ```
        
- **堆區：**
    - **範例：**
        
        ```c
        int *ptr = (int *)malloc(sizeof(int));
        
        ```
        
- **堆疊：**
    - **範例：**
        
        ```c
        // call function
        void function() {
            int local_var;
        }
        
        ```
        

### **Extern 變數**

- **概念：**
    - `extern` 關鍵字用於宣告一個在其他文件或作用域中定義的全域變數或函數。
- **存放區域：**
    - **定義位置決定存放區域：**
        - 變數的存放區域取決於其定義（而非宣告）的位置和初始化情況。
        - 如果在文件A中定義了一個全域變數，在文件B中使用 `extern` 進行宣告，那麼該變數的存放區域由定義決定，而不是宣告。
- **存儲區段：**
    - **已初始化的 extern 變數：**
        - 存放在 **初始化數據段（.data）**。
        - **範例：**
            
            ```c
            // file1.c
            int global_var = 100; // 定義並初始化
            
            // file2.c
            extern int global_var; // 宣告
            
            ```
            
    - **未初始化的 extern 變數：**
        - 存放在 **未初始化數據段（.bss）**。
        - **範例：**
            
            ```c
            // file1.c
            int global_var; // 只定義未初始化
            
            // file2.c
            extern int global_var; // 宣告
            
            ```
            
- **特點：**
    - **外部鏈接性：** `extern` 變數具有全域作用域，可在多個文件中訪問。
    - **單一實例：** 不管有多少個 `extern` 宣告，實際上只有一個定義，確保數據一致性。
- **注意事項：**
    - **宣告 vs 定義：** `extern` 關鍵字只是宣告，不會分配內存；只有定義才會分配內存並決定存放區域。
    - **初始化：** 在宣告中不能對 `extern` 變數進行初始化，初始化應該在定義時完成。

### **性能和安全性的影響**

- **性能：**
    - **內存區域選擇：** 合理使用內存區域（如優先使用堆疊變數）可以提升程式性能。
    - **內存局部性：** 利用內存的空間和時間局部性，提升快取命中率，減少訪問延遲。
- **安全性：**
    - **內存保護機制：** 防止緩衝區溢出、非法訪問等漏洞，提高程式的安全性。
    - **只讀區域設置：** 保護程式碼和常量不被修改，防止惡意代碼注入。